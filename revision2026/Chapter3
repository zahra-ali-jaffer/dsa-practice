//ADTs and Collections
//An Abstract Data Type (or ADT) is a specification of a set of data, and the set of operations that can be performed on it.
//It’s abstract because the focus is on defining properties on the data, and the behaviour of the operations, rather than the exact implementation 

//2 bits of Information (abstract structure of the data, and typical operations that can be performed on it)

//Collections --> group of other objects of a fixed type

ArrayList<Book> bookshelf = new ArrayList<>(100);
java.util.HashSet<Treasure> myTreasure = new java.util.HashSet<>();
java.util.HashMap<String, Correspondence> phoneBook = new java.util.HashMap<>(25);

//Categorising collections -> Formation, Organisation, Size
//Formation -> Unordered, Linear and Non-Linear
//Organisation -> Order they were added, Dependant on relationship between elements
//Size -> Bounded(Fixed size), Unbounded(Dynamic)

//All Collections -> isEmpty() & size()
//Bounded Collections also -> isFull() & capacity()

//Exceptions
public Map<Prize, Ticket> luckyDraw(){
  Map<Prize, Ticket> winners = new HashMap<>();
  try { //Important 
    for (Prize prize : prizes) {
      winners.put(prize, tickets.draw()); //Normal case
    }
  } catch (IllegalStateException ise) {//Looking for specific error
    return winners; // Error case
  }
  return winners;
}

//Bounded Collection - Modelling isFull() and capacity()

public interface Bounded {
  /** Returns true if collection has no more room for more elements */
  public boolean isFull(); // Remember, interfaces have no bodies on methods
  
  /** Returns the maximum elements a collection can hold */
  public int capacity();
}

//Bounded shouldn’t need to extend java.lang.Iterable because that’s a feature of a collection
//Java interfaces (not the other type of interface) typically define a set of abstract methods, such as public abstract int size(); but will not contain any data members(fields)
//Classes and interfaces modelling collections should be generic 
//Regardless of what the collection is storing -> it will count the elements in the same way to determine the size of the collection.

//Collection ADTs
//Stacks

public interface StackADT<T> {
  public void push(T el);
  public T pop();
  public T peek();
  public boolean isEmpty();
  public int size();
}

//Bounded Stack
public interface BoundedStackADT<T>
extends StackADT<T>, Bounded{
/*...*/
}

//Or 
public interface BoundedStackADT<T>
extends StackADT<T> {
	public boolean isFull();
	public int capacity();	
}

//Queues
//isEmpty(), size(), toString(), enqueue(), dequeue(), first()

//Lists 
//Linear, elements can be added or removed anywhere, More Flexible, Can contain duplicate values
//isEmpty(), size(), toString(), removeFirst(), removeLast(), remove(Object), first(), last(), Iterator()-> Extending Iterable<T>

//Maps
//Non-linear, Maps keys to values, keys have to be unique
//add(), reassign(), remove(), lookup()
//Should a MapADT extend Iterable?
//No, it’d be better to add methods such as keySet() and valueSet() to the ADT to facilitate looping over the keys or values in the map respectively.

//Sets
//Unordered, technically non-linear collection of unique elements of a particular type.
//isEmpty(), size(), toString(), add(), addAll(), remove(), removeFirst(), removeLast(), remove(Object), removeAll(), retainAll(), contains(), equals(), isSubset(), union(), intersection(), difference(), pick(), removeRandom() and iterator() -> by extending Iterable<T>

public interface SetADT<T> extends Iterable<T> {
  public boolean add(T element); // Returns bool to indicate if the set changed or not
  public boolean addAll(SetADT<T>A);
  public boolean remove(T element);
  public boolean removeAll(SetADT<T> A); // Removes all elements of set A from this set
	public boolean retainAll(SetADT<T> A); // Removes all elements EXCEPT those in set A
	public SetADT<T> union(SetADT<T> A); // Returns this ∪ A
	public SetADT<T> intersection(SetADT<T> A); // this ∩ A
	public SetADT<T> difference(SetADT<T> A); // this \ A
	public boolean isSubset(SetADT<T> A); // this ⊆ A
	public boolean contains(T element);
	public boolean equals(SetADT<T> A);
	public boolean isEmpty();
	public int size();
}

//Multi-sets
//Elements can appear more than once. They are still unordered
//They remain the same as a set, with the difference being that duplicate elements must be accounted for.
//Two methods can be added -> count(T element), sum()
//count(T element)  - returns the number of occurrences of an element in a multi-set
//sum() - concatenates the two multisets together, like {d,e,n} + {d,a,n,n,i} = {d,e,n,d,a,n,n,i}

}





