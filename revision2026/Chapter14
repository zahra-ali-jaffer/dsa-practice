//Unit 14. Sorting and Searching
//Implementing java.lang.Comparable interface

public class Location implements Comparable<Location> {
  private int x;
  private int y;

  public Location(int x, int y) {
    this.x = x;
    this.y = y;
  }
  public int compareTo(Location another){
    if (this.x == another.x){
      return this.y - another.y;
    }
    else {
      return this.x - another.x;
    }
  }
}

//If we are to order two Location objects by first their x coordinates and then by
their y coordinates

Location loc1 = new Location(1,2);
Location loc2 = new Location(4,5);

//negative integer being assigned to the variable result
int result = loc1.compareTo(loc2)

// Define a class named SortingAndSearching to hold the implementations. This class uses generic type to ensure that it works with objects that implement the Comparable
interface.
public class SortingAndSearching<T extends Comparable<T>> {
}

//Instance methods do not operate on any instance variables (i.e. fields), we can implement those algorithms as class methods 
public static<T> void linearSearch(T[] data, T target){
}

//Without the use of constructors to specify the required constraint for the type variable T as a
kind of Comparable type, the required constraint will need to be added to the type variable
declaration in each method explicitly as below, i.e. between the keywords static and void

public static <T extends Comparable<T>> void insertionSort(T[] data){
}

//Linear Search
public int linesrSearch(T[] data, int min, int max, T target) {
  int index = min;
  int comp; //result of comparison

  while (index <= max) {
    comp = target.compareTo(data[index]);
    if (comp == 0) //target found
      return index;
    else if (comp < 0) //target not present
      return - index - 1;
    else
      index++;
  }
  return - index - 1; //target not present
}

//a linear search is O(n)
//With LinearSearch, if the negative value returned is −m, then m − 1 gives the index at which the target should be inserted into the array (if insertion is required).


//Binary Search
public int binarySearch(T[] data, int min, int max, T target) {
  int midpoint = (min + max)/2; //determine midpoint
  int comp = target.compareTo(data[midpoint]);

  if(comp == 0)
    return midpoint;
  else if (comp < 0)
    //target is in the left of the array
    if (min <= midpoint - 1)
      return binarySearch(data, min, midpoint - 1, target);
    else
      return -midpoint-1; //element not present
  else //the ttarget is in the right half of the array
    if (midpoint + 1 <= max)
      return binarySearch(data, midpoint + 1, max, target);
    else
      return -midpoint-2; // element not present
}

//time efficiency of the binary search is O(log2 n) (Logarithmic sorts, e.g. quick sort and merge sort, typically require n × log2(n) comparisons
to sort n elements | Sequential sorts require approximately n^2 comparisons to sort n elements)
//worst case for a binary search is log2(n) 

//Method binarySearch(T[], int, int, T) returns the index of the target if it is found or a negative value if not

//Insertion Sort - “in-place” sorting process
for (int index = 1; index < data.length; index++ ) {
    T currentElement = data[index];
    int position = index; //current sort position

    //Shift larger values to right
    while (position > 0 &&
          data[position-1].compareTo(currentElement) > 0) 
    {
          data[position] = data[position-1];
          position--;
    }
    //Insert the element
    data[position] = currentElement; 
  }
}

//The header for method insertionSort which does not perform “in-place” sort:
public List<T> insertionSort(T[] data)
