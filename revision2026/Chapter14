//Unit 14. Sorting and Searching
//Implementing java.lang.Comparable interface

public class Location implements Comparable<Location> {
  private int x;
  private int y;

  public Location(int x, int y) {
    this.x = x;
    this.y = y;
  }
  public int compareTo(Location another){
    if (this.x == another.x){
      return this.y - another.y;
    }
    else {
      return this.x - another.x;
    }
  }
}

//If we are to order two Location objects by first their x coordinates and then by
their y coordinates

Location loc1 = new Location(1,2);
Location loc2 = new Location(4,5);

//negative integer being assigned to the variable result
int result = loc1.compareTo(loc2)

// Define a class named SortingAndSearching to hold the implementations. This class uses generic type to ensure that it works with objects that implement the Comparable
interface.
public class SortingAndSearching<T extends Comparable<T>> {
}

//Instance methods do not operate on any instance variables (i.e. fields), we can implement those algorithms as class methods 
public static<T> void linearSearch(T[] data, T target){
}

//Without the use of constructors to specify the required constraint for the type variable T as a
kind of Comparable type, the required constraint will need to be added to the type variable
declaration in each method explicitly as below, i.e. between the keywords static and void

public static <T extends Comparable<T>> void insertionSort(T[] data){
}

//Linear Search
public int linesrSearch(T[] data, int min, int max, T target) {
  int index = min;
  int comp; //result of comparison

  while (index <= max) {
    comp = target.compareTo(data[index]);
    if (comp == 0) //target found
      return index;
    else if (comp < 0) //target not present
      return - index - 1;
    else
      index++;
  }
  return - index - 1; //target not present
}
