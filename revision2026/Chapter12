//Recursion

//Iterative vs Recursive --> size without count field

//Iterative
public int size(){
  LinkedNode<T> cursor = front;
  int count = 0;
  while (cursor!- null) {
    count++;
    cursor = cursor.getNext();
  }
  return count;
}

//Recursive
//In List
public int size() {
  return front.size();
}
//In Node
public int size(){
  if (next == null) return 1;
  else return 1 + next.size();
}

//A method that invokes itself -> Recursive
public int sum(int n) {
  if (n == 1) return 1; //Base case
  else return n + sum(n - 1); //Recursive step, keeps going until n == 1
}

//If no base case -> Infinite recursion -> Stack Overflow
public void printOnes(){
  System.out.print(1);
  printOnes();
}

//^Error when code executed, the issue is that there’s no base case, no non-recursive part to stop it from recursively infinitely.

//Processing Linear Linked Structures with Recursion
//Implement size(), toString() and copy() with recursion

public class LinearNode<T>{
  private LinearNode<T> next;
  private T element;
  /*...*/

  public int size(){
    if(next == null) return 1; // Base case
    else return 1 + next.size(); // Recursive case
  }

  // toString() is basically the same idea
  public String toString() {
    if (next == null) return element.toString(); //Base case
    else return element.toString() + ", " + next.toString(); //Recursive step
  }

  public LinearNode<T> copy() {
    LinearNode<T> current = new LinearNode<T>(element);
    if (next != null) {
      current.next = next.copy(); // everything must be copied
    }
    // Base case (not explicitly wriiten) is next == null
    return current;
  }
}

//Change in LinkedList Class
public class LinkedList<T>{
  private LinearNode<T> front;
  /*...*/
  public String toString(){
    String result = "{";
    if (front != null) result += front.toString();
    result += "}";
    return result;
  }
  public LinkedList<T> copy(){
    LinkedList<T> result = new LinkedList<>();
    if(front != null) result.front = front.copy();
    return result;
  }
}

//Since the above requires too many changes, changing the methods only in LinkedList -> to make it recursive (without going into the nodes itself)

public class LinkedList<T>{
  private LinearNode<T> front;
  /*...*/
  public LinkedList<T> copy(){
    LinkedList<T> result = new LinkedList<>();
    if (front != null) result.front = this.copy(front);
    return result;
  }
  private LinearNode<T> copy(LinearNode<T> node){
    LinearNode<T> current = new LinearNode<>(node.getElement());
    if (node.getNext() != null) current.setNext(this.copy(node.getNext()));
    return current;
  }
}

//Example -> Tower of Hanoi
private void moveTower(int numDisks, int start, int end, int temp) {
  if (numDisks == 1) moveOnDisk(start, end);
  else {
    moveTower(numDisks - 1, start, temp, end);
    moveOneDisk (start, end);
    moveTower(numDisks-1, temp, end, start);
  }
}
private void moveOneDisk(int start, int end){
  System.out.println("Move one disk from" + start + "to" + end);
}
//for every iteration of moveTower() (excluding the base case), we make two extra executions of moveTower(), and then even on the base case, we make one moveOneDisk()

//Fibonacci Numbers
//Inefficient method - takes 2^(n-1) + 1 steps to find the nth number
public int fib(int n){ //Calculate nth Fibonacci Number
  if (n == 0 || n == 1) return 1; //Base case
  else return fib(n - 1) + fib(n - 2);
}

//Efficient method - O(n)
public int fib(int n){
  if (n == 0 || n ==1 ) return 1;

  int f0 = 1; int f1 = 1; int result;
  for (int i = 2; i <= n; i++) {
    result = f0 + f1;
    f0 = f1;
    f1 = result;
  }
  return result;
}

//Every recursive solution has a corresponding iterative solution. 
//Recursion solutions, in some cases, can be simpler and more elegant than the iterative version, but since every call makes a new execution environment, there’s a lot more overhead.
//Iterative solutions can be perform better, and even just be more suitable than recursion, such as for summing numbers from 1 to N, or for calculating factorials.
