//Improving code(unit 5 - Person class- Self referential object)
//Making it doubly-linked

public enum Gender { male, female, other; }
public class Person{
  private String name;
  private Gender gender;
  private Person mother; //link to another person object
  private Person child; //self-referential

  public Person(String name, Gender gender, Person mother)
    this.gender = gender;
    this.name = name;
    this.mother = mother;
    this.child = null;
}

  public Person givesBirth(String childName,Gender childGender) {
    if (this.gender != Gender.female) System.out.println("Gender is Female!")
    if (this.child != null) new UnsupportedOperationException("One child only!")

    this.child = new Person(childName, childGender, this);
    return this.child;
  } 

//Doubly-Linked Lists

public class DoubleNode<T> {
  private DoubleNode<T> previous;
  private DoubleNode<T> next;
  private T element;

  public DoubleNode(T elem) {
    previous = null; 
    next = null; 
    element = elem;
  }
  public DoubleNode<T> getPrevious() {return previous; }
  public void setPrevious(DoubleNode<T> node) {previous = node;}
  public DoubleNode<T>getNext() {return next; }
  public void setNext(DoubleNode<T>node) {next = node; }
}

/*With doubly linked list, it's easier to support remove() 
operation of an Iterator*/

cursor.previous().setNext(cursor.next()):
cursor.cursorNext();

//This is an advantage of using a Doubly-Linked List. 
//Another advantage is going forwards or backwards
//And a list can now be processed in reverse order.

/*Con of this is three elements to keep track of. 
This increases overhead in both storage (more links needed) 
and time (need to update both)*/

//Modelling Doubly-Linked Lists

import java.util.Iterator;

public abstract class DoubleList<T> {
  protected DoubleNode<T> front;
  protected DoubleNode<T> rear;
  protected int count;

  protected DoubleList() {
    rear = null; front = null; count = 0;
  }
  protected T removeLast() //Return the element at the back, remove the node
    if (isEmpty()) throw new IllegalStateException("removeList: List is Empty!");

    T result = rear.getElement();
    rear = rear.getPrevious;
    count--;

    if (rear == null) front = null;
    else rear.setNext(null);

    return result;
  }
  protected T removeFirst() { 
    if(isEmpty()) throw new IllegalStateException("removeFirst: List Empty!");

    T result = front.getElement();
    front = front.getNext();
    count--;

    if (front == null) rear = null; 
    else front.setPrevious(null);

    return result;
  }
  protected void remove(DoubleNode<T> node){
    if (node == null) throw new IllegalArgumentException("remove: node cannot be null!");
    if (isEmpty()) throw new IllegalStateException("remove: list empty!");

    if (node == front) this.removeFirst(); //Easier to reuse than redo methods
    else if (node == rear) this.removeLast();
    else {
      node.getNext().setPrevious(node.getPrevious());
      node.getPrevious().setNext(node,getNext());
      count--;
    }
  }
  protected void addFirst(T element) {
    DoubleNode<T> node = new DoubleNode<T>(element);
    node.setNext(front);
    front = node;
    if(count == 0) rear = node; //  Count not updated yet for this reason
    else {
      front.getNext().setPrevious(node);
    }
    count++;
  }

//Also addLast() --> similar way

  protected void addAfter(DoubleNode<T> current, T element){
    if (current == null)
      throw new IllegalArgumentException("addAfter: node cannot be null");
    if (current == rear) addLast(element);

    else{
      DoubleNode<T> node = new DoubleNode<T>(element);
      node.setNext(current.getNext());
      node.setPrevious(current);
      current.getNext().setPrevious(node);
      current.setNext(node);
      count++
    }
  }

//Similarly --> addBefore()

  protected DoubleNode<T> find(T target) {
    DoubleNode<T> cursor: front;
    while (cursor!= null) {
      if(target.equals(cursor.getElement())) return cursor;
      else cursor = cursor.getNext();
    }
    return null;
  }
  protected boolean contains(T element) {return find(element) != null; }  
  public boolean isEmpty() {return count == 0; }
  public int size() { return count;}
  public void clear() {front = null; rear = null; count = 0; }
  public Iterator<T> iterator() { return new DoibleIterator(); }

  //NESTED CLASS- also supportd the remove operation
  
  private class DoubleIterator implements Iterator<T> { //Implicitly generic
    //We also already have access to all the data fields in DoubleList!
    private DoubleNode<T> cursor; // next node to be returned by next
    private DoubleNode<T> node; // node just returned by next, to be removed

    public DoubleIterator() {cursor = front; node = null; }
    public boolean hasNext() { return cursor!= null; }
    public boolean T next() {
      if (!hasNext()) throw new IllegalStateException("next: no next element!");
      node = cursor; //NEW
      T result = cursor.getElement();
      cursor = cursor.getNext();
      return result;
    }
    public void remove() {
      if(node == null) throw new IllegalStateException("remove: nothing to remove");
     
      if (node == rear) {//last element
        rear = rear.getPrevious();
        if (rear == null) front = null; // List had 1 element, now empty
        else rear.setNext(null);
      }
      else if (node == front) { //front element
        front = front.getNext();
        front.setPrevious(null); //No edge case, List must have more than 1 element
      }
      else {
        node.getPrevious().setNext(node.getNext());
        node.getNext().setPrevious(node.getPrevious());
      }
      count--;
      node = null; // Stops remove() from being called twice in one next() call
    }
  }
}

//List Operations (Headers of the interfaces)

public interface ListADT<T> extends Iterable<T>{}
/* .add(Comparable) requires that T extends Comparable so we put that in the defintion.
	 Then, .add() will use T's compareTo() method to determine where to place elements, 
			< 0 means this should preceed the given element
			= 0 means it has the same natural order as the given element
			> 0 means this should come after the given element. */

public interface OrderedListADT<T extends Comparable<T>> extends ListADT {}
public interface UnorderedListADT<T> extends ListADT{}
public interface IndexedListADT<T> extends ListADT{}

//Using an Ordered List
//compareTo() method --> Keep track of Employee objects, sorting by their seniority and then their names alphabetically. 

public class Employee implements Comparable<Employee> {
/* ... */
public int compareTo(Employee another){
	int result;

	//Approach 1
	if (this.years > another.getYears()) result = 1;
	else if (this.years < another.getYears()) result = -1;
	else result = this. name.compareTo(another.getName());

	//Approach 2
	if (this.years == another.getYears()) result = this.name.compareTo(another.getName());
	else result = this.years - another.getYears()
	return result;
}
/* ... */
}

//Implementing following methods
public class LinkedOrderedList<T extends Comparable<T>> 
	extends DoubleList<T> implements OrderedListADT<T>{ //Gains access to: front, rear, DoubleNode<T> & methods like addFirst(), addLast(), removeLast(), find()
	// Since some methods are already defined in DoubleList, we can use the super modifier
	public LinkedOrderedList() { super (); }

	public boolean remove(T element) {
		DoubleNode<T> tmp = super.find(element);
		if (tmp == null) return false;
		super.remove(tmp); //If found → remove that node
		return true;
	}
	public void add(T element) {
		if (front == null) { super.addFirst(element); return; } //If the list is empty, add the element as the first node
		// Look for entry position
		DoubleNode<T> cursor = front;
		while (cursor!= null && element.compareTo(cursor.getElement())>0)
			cursor = cursor.getNext() //maintains ascending order
		if (cursor == null) super.addLast(element); //Add last, Reached end --> Add element to the end
		else super.addBefore(cursor, element); // Add element before cursor node, Found larger element -- > Insert before that node
	}
	public T first() {
		if (front == null) throw new IllegalStateException("first: no first element");
		return front.getElement(); //Returns the smallest element (because list is ordered)
	}
	public T removeLast() {return super.removeLast(); } // Exposes the protected class
}

//Using an Indexed List
//Define a private findNode(n) method which returns the DoubleNode<T> at the nth index of the list.

public class LinkedIndexedList<T> extends DoubleList<T> implements IndexedListADT<T>{ //Inherits a doubly linked list, and Guarantees support for index-based operations
	public LinkedIndexedList() { super(); } //Calls the constructor of DoubleList, initialises front = null, rear = null, count = 0
	private DoubleNode<T> findNode(int i) {
		if (i < 0 || i >= count) //Converts an index into a node reference
			throw new IllegalArgumentException("findNode: index parameter OutOfBounds");
		DoubleNode<T> current = front;
		for (int cursor = 0; cursor < i; cursor++) current = current.getNext(); //Starts at the front node, Moves forward i times, Returns the node at position i
		return current;
	}
	public T get(int idx){ //Retrieves the node at index idx
		return findNode(idx).getElement();
	}
	public T set(int idx, T element) { //Returns old element
		DoubleNode<T> node = findNode(idx);
		T res = node.getElement();
		node.setElement(element);
		return res;
	}
	public T remove(int idx){ //Replaces the element at index idx, Returns the old value
		DoubleNode<T> node = findNode(i)
		super.remove(node);
		return node.getElement();
	}
	public void add(int idx, T element){ 
		if (i == 0) super.addFirst(element); // New first element
		else if (i == count) super.addLast(element); //New rear element
		else {
			DoubleNode<T>next = findNode(i); //Insert in middle
			super.addBefore(next, element);
		}
	}
	public int indexOf(T target) {
		DoubleNode<T> cursor = front;
		int pos = 0;

		while (cursor != null){ //Search Loop
			if (target.equals(cursor.getElement())) return pos; //Traverses list sequentially, uses .equals() for comparison
			else {
				pos++;
				cursor = cursor.getNext(); //Stops when found
			}
		}
		return -1; //Not found
	}
}

//Most time complexities are O(n)
//Linked lists are not ideal for random access, but excel at insertions/removals once a node is located.


//Implementing Lists with Arrays
//Example: Like a queue, fix one end to index 0 and shift as needed. 
//Why not circular array?
/*we cannot use a circular array approach to solve shifting here, because we 
can remove things from the middle of the list, unlike a queue.*/

//With an Indexed Lists
public class ArrayList<T> implements IndexedListADT<T>{
	public static final int DEFAULT_CAPACITY = 20;
	private T[] elements;
	private int size;
	private int capacity;

	public ArrayList(int initCapacity){
		elements = (T[]) (new Object[initCapacity]); 
		size= 0;
		capacity = initCapacity;
	}
	public ArrayList() { this(DEFAULT_CAPACITY); }
	public int size() { return size; }
	public boolean isEmpty() { return size == 0; }
	public void clear() {size = 0; } //clear() does not delete the array, It just “forgets” stored elements by resetting size, Efficient: O(1)
	public boolean contains (T elem){ return indexOf(elem) !=-1; }
	
	// Considering this'll only happen when adding, leave a gap
	// so no need to shift again once this is done.
	private void extendArray(int gap){
		capacity *= 2;  //Doubles array size when full
		T[] newArray = (T[]) (new Array.newInstance(Object.class,capacity));
		// Splitting this into two loops increases efficiency, because there isn't a 
		// statement in the middle that adds extra processing.
		for (int i = 0; i < gap; i++) {newArray[i] = elements[i]; } //Leaves a gap at index gap for insertion
		for (int i = gap; i < size; i++) { newArray[i + 1] = elements[i]; }
		elements = newArray;
	}
	public void add (int idx, T element){
		if (idx < 0 || idx > size) // idx == size is allowed, idx == size means add at end
		if (size == capacity) extendArray(idx); //When full, grow array and leave gap
		else { // Shift everything up by one, starting from the end!
			for (int j = size; j > idx; j++) { elements[j]=elements[j - 1]; } //If there is space, shift elements right by one
		}
		elements[idx] = element;
		size++;
	}
	public int indexOf(T elem){ //Linear search, Uses .equals() (correct for objects), O(n)
		for (int i = 0; i < size; i++){
			if (elem.equals(elements[i])) return i;
		}
		return -1; // not found!
	}
	public T get(int idx){
		if (idx < size && idx >= 0) return elements[idx];
		else throw new IllegalStateException ("set: index OutOfBounds");
	}
	public T set(int idx, T element)  //Return old element 
		if (idx < size && idx >= 0) {
			T res = elements[idx];
			elements [idx] = element;
			return res;
		} else throw new IllegalArgumentException("set: index OutOfBounds");
	}
	public T remove (int idx) {
		if(idx < 0 || idx > size)
			throw new IllegalArgumentException("remove: index OutOfBounds");
		T elem = elements[idx];
		// Shift everything after idx back down
		for(int j = idx + 1; j < size; j++) {elements[j - 1] = elements[j]; } //Store element to return, Shift elements left, Decrease size - O(n) due to shifting
		size --;
		return elem;
	}
	public Iterator<T> iterator() {return new ArrayIterator(); }

	private class ArrayIterator implements Iterator<T> {
		private int cursor;
		private int current;
		public ArrayIterator() {cursor = 0; current = -1;}
		public boolean hasNext() {return cursor < size; }
		public T next(){
			if (!hasNext()) throw new IllegalStateException("next: no next element!");
			current = cursor;
			T result = elements[cursor];
			cursor++;
			return result;
		}
		public void remove() { //Removes last returned element, shifts array left, prevents repeated removal
			if (current == -1)
				throw new IllegalStateException("remove: no element to remove!");
			for (int i= current; i < size; i++) {elements[i] = elements[i + 1]; }
			size--;
			cursor--;
			current = -1; //To prevent re-run
		}
	}
}








