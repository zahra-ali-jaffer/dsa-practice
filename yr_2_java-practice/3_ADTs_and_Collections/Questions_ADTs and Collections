//Question 1 - Array Stack (Bounded)- Write a generic class ArrayStack<T> that implements StackADT<T> using an array.

//Answer 1:
public class ArrayStack<T> implements StackADT<T>, Bounded {
  private T[] stack;
  private int top;

  public ArrayStack(int capacity) {
    stack = (T[]) new Object[capacity];
    top = 0;
  }

  public void push (T element) {
    if (isFull()) throw new IllegalStateException("Stack is full!");
    stack[top++] = element;
  }

  public T pop() {
    if (isEmpty()) throw new IllegalStateException("Stack is empty!");
    T item = stack[--top];
    stack[top] = null;
    return item;
  }

  public T peek() {
    if (isEmpty()) throw new IllegalStateException("Stack is empty");
    return stack[top - 1];
  }

  public boolean isEmpty(){ return top == 0; }
  public int size() { return top; }
  public boolean isFull() { return top == stack.length; }
  public int capacity() { return stack.length; }
}


//Question 2 - Linked Stack (Unbounded) - Implement LinkedStack<T> using a singly linked list.

//Answer 2:

public class LinkedStack<T> implements StackADT<T>{
  private Node<T> top;
  private int size;

  private static class Node<T>{
    T data;
    Node<T> next;
    Node (T data, Node<T> next) {
      this.data = data;
      this.next = next;
    }
  }
    public void push(T element){
    top = new Node<>(element, top);
    size++;
  }
  public T pop() {
    if (isEmpty()) throw new IllegalStateException("Stack empty");
    T item = top.data;
    top = top.next;
    size--;
    return item;
  }
  public T peek(){
    if (isEmpty()) throw new IllegalStateException("Stack empty");
    return top.data;
  }
  public boolean isEmpty(){ return size == 0; }
  public int size() { return size; }
}

//Question 3 - Trace Question - Trace stack contents after:

/*push(10); push(20); push(30);
pop();
push(40);
peek();*/

//Answer 3:
/**push(10) → [10]
push(20) → [20,10]
push(30) → [30,20,10]
pop()    → [20,10]
push(40) → [40,20,10]
peek()   → 40

Final stack (top → bottom): 40, 20, 10*/

//Question 4 - Modify pop() so it throws IllegalStateException when stack is empty.

//Answer 4:
public T pop() {
  if (isEmpty()) throw new IllegalStateException("Stack empty");
  T item = top.data;
  top = top.next;
  size--;
  return item;
}

//Question 5 - Interface - Write the interface QueueADT<T>.

//Answer 5:
public interface QueueADT<T>{
  void enqueue(T element);
  T dequeue();
  T first();
  boolean isEmpty();
  int size();
}

//Question 6 - Circular Array Queue - Implement a bounded queue using a circular array.

//Answer 6:
private class CircularArrayQueue<T> implements QueueADT<T>, Bounded {

  private T[] queue;
  private int front = 0, rear = 0, size = 0;

  public CircularArrayQueue(int capacity) {
    queue = (T[]) new Object[capacity];
  }
  public void enqueue(T element) {
    if (isFull()) throw new IllegalStateException("Queue full");
    queue[rear] = element;
    rear = (rear + 1) % queue.length;
    size++;
  }
  public T dequeue(){
    if (isEmpty()) throw new IllegalStateException("Queue empty");
    T item = queue[front];
    queue[front] = null;
    front = (front + 1) % queue.length;
    size--;
    return item;
  }
  public T first() {
    if (isEmpty()) throw new IllegalStateException("Queue empty");
    return queue[front];
  }
  public boolean isEmpty() {return size == 0;}
  public int size() { return size; }
  public boolean isFull() { return size == queue.length; }
  public int capacity() { return queue.length; }
}

//Question 7 - Linked Queue -Write a class LinkedQueue<T> using front and rear pointers.

//Answer 7:
public class LinkedQueue<T> implements QueueADT<T> {

    private Node<T> front, rear;
    private int size;

    private static class Node<T> {
        T data;
        Node<T> next;
        Node(T data) { this.data = data; }
    }

    public void enqueue(T element) {
        Node<T> newNode = new Node<>(element);
        if (isEmpty()) front = newNode;
        else rear.next = newNode;
        rear = newNode;
        size++;
    }

    public T dequeue() {
        if (isEmpty()) throw new IllegalStateException("Queue empty");
        T item = front.data;
        front = front.next;
        if (front == null) rear = null;
        size--;
        return item;
    }

    public T first() {
        if (isEmpty()) throw new IllegalStateException("Queue empty");
        return front.data;
    }

    public boolean isEmpty() { return size == 0; }
    public int size() { return size; }
}

//Question 8 - Explain why a supermarket checkout is modeled by a queue rather than a stack.

//Answer 8:
/*Because customers are served first-come, first-served (FIFO). A stack is LIFO, which would serve 
the last customer first.*/

//Question 9 - Node Class - Write a generic Node<T> class for a singly linked list.

//Answer 9:
class Node<T> {
  T data;
  Node<T> next;
  Node(T data) { this.data = data; }
}

//Question 10 - Doubly Linked Node - Write a node class with prev and next.

//Answer 10:
class DNode<T> {
  T data;
  DNode<T> next, prev;
  DNode(T data){ this.data = data; }
}

//Question 11 - Method Writing
//In DoublyLinkedList<T> write:

/*public void addLast(T element)*/

//Question 12 - Write addFirst(T element).

//Question 13 - Write removeFirst() that throws exception if empty.

//Question 14 - Write a traversal method that prints elements from head to tail.

//Question 15 - ADT vs Data Structure - Explain the difference and give one example of each.

//Question 16 - Bounded vs Unbounded - Give one Java example of each and explain.

//Question 17 - Exception Scenario - Why must removing from an empty collection throw an exception?

//Question 18 - Write a method that reverses a stack using only stack operations.

//Question 19 - Implement a queue using two stacks



