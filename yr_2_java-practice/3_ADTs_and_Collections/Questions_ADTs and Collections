//Question 1 - Array Stack (Bounded)- Write a generic class ArrayStack<T> that implements StackADT<T> using an array.

//Answer 1:
public class ArrayStack<T> implements StackADT<T>, Bounded {
  private T[] stack;
  private int top;

  public ArrayStack(int capacity) {
    stack = (T[]) new Object[capacity];
    top = 0;
  }

  public void push (T element) {
    if (isFull()) throw new IllegalStateException("Stack is full!");
    stack[top++] = element;
  }

  public T pop() {
    if (isEmpty()) throw new IllegalStateException("Stack is empty!");
    T item = stack[--top];
    stack[top] = null;
    return item;
  }

  public T peek() {
    if (isEmpty()) throw new IllegalStateException("Stack is empty");
    return stack[top - 1];
  }

  public boolean isEmpty(){ return top == 0; }
  public int size() { return top; }
  public boolean isFull() { return top == stack.length; }
  public int capacity() { return stack.length; }
}


//Question 2 - Linked Stack (Unbounded) - Implement LinkedStack<T> using a singly linked list.

//Answer 2:

public class LinkedStack<T> implements StackADT<T>{
  private Node<T> top;
  private int size;

  private static class Node<T>{
    T data;
    Node<T> next;
    Node (T data, Node<T> next) {
      this.data = data;
      this.next = next;
    }
  }
    public void push(T element){
    top = new Node<>(element, top);
    size++;
  }
  public T pop() {
    if (isEmpty()) throw new IllegalStateException("Stack empty");
    T item = top.data;
    top = top.next;
    size--;
    return item;
  }
  public T peek(){
    if (isEmpty()) throw new IllegalStateException("Stack empty");
    return top.data;
  }
  public boolean isEmpty(){ return size == 0; }
  public int size() { return size; }
}

//Question 3 - Trace Question - Trace stack contents after:

/*push(10); push(20); push(30);
pop();
push(40);
peek();*/

//Answer 3:
/**push(10) → [10]
push(20) → [20,10]
push(30) → [30,20,10]
pop()    → [20,10]
push(40) → [40,20,10]
peek()   → 40

Final stack (top → bottom): 40, 20, 10*/

//Question 4 - Modify pop() so it throws IllegalStateException when stack is empty.

//Answer 4:
public T pop() {
  if (isEmpty()) throw new IllegalStateException("Stack empty");
  T item = top.data;
  top = top.next;
  size--;
  return item;
}

//Question 5 - Interface - Write the interface QueueADT<T>.

//Answer 5:
public interface QueueADT<T>{
  void enqueue(T element);
  T dequeue();
  T first();
  boolean isEmpty();
  int size();
}

//Question 6 - Circular Array Queue - Implement a bounded queue using a circular array.

//Answer 6:
private class CircularArrayQueue<T> implements QueueADT<T>, Bounded {

  private T[] queue;
  private int front = 0, rear = 0, size = 0;

  public CircularArrayQueue(int capacity) {
    queue = (T[]) new Object[capacity];
  }
  public void enqueue(T element) {
    if (isFull()) throw new IllegalStateException("Queue full");
    queue[rear] = element;
    rear = (rear + 1) % queue.length;
    size++;
  }
  public T dequeue(){
    if (isEmpty()) throw new IllegalStateException("Queue empty");
    T item = queue[front];
    queue[front] = null;
    front = (front + 1) % queue.length;
    size--;
    return item;
  }
  public T first() {
    if (isEmpty()) throw new IllegalStateException("Queue empty");
    return queue[front];
  }
  public boolean isEmpty() {return size == 0;}
  public int size() { return size; }
  public boolean isFull() { return size == queue.length; }
  public int capacity() { return queue.length; }
}

//Question 7 - Linked Queue -Write a class LinkedQueue<T> using front and rear pointers.

//Answer 7:
public class LinkedQueue<T> implements QueueADT<T> {

    private Node<T> front, rear;
    private int size;

    private static class Node<T> {
        T data;
        Node<T> next;
        Node(T data) { this.data = data; }
    }

    public void enqueue(T element) {
        Node<T> newNode = new Node<>(element);
        if (isEmpty()) front = newNode;
        else rear.next = newNode;
        rear = newNode;
        size++;
    }

    public T dequeue() {
        if (isEmpty()) throw new IllegalStateException("Queue empty");
        T item = front.data;
        front = front.next;
        if (front == null) rear = null;
        size--;
        return item;
    }

    public T first() {
        if (isEmpty()) throw new IllegalStateException("Queue empty");
        return front.data;
    }

    public boolean isEmpty() { return size == 0; }
    public int size() { return size; }
}

//Question 8 - Explain why a supermarket checkout is modeled by a queue rather than a stack.

//Answer 8:
/*Because customers are served first-come, first-served (FIFO). A stack is LIFO, which would serve 
the last customer first.*/

//Question 9 - Node Class - Write a generic Node<T> class for a singly linked list.

//Answer 9:
class Node<T> {
  T data;
  Node<T> next;
  Node(T data) { this.data = data; }
}

//Question 10 - Doubly Linked Node - Write a node class with prev and next.

//Answer 10:
class DNode<T> {
  T data;
  DNode<T> next, prev;
  DNode(T data){ this.data = data; }
}

//Question 11 - Method Writing
//In DoublyLinkedList<T> write:

/*public void addLast(T element)*/

public void addLast(T element) {
    DNode<T> newNode = new DNode<>(element);

    if (size == 0) {
        head = tail = newNode;
    } else {
        tail.next = newNode;
        newNode.prev = tail;
        tail = newNode;
    }
    size++;
}

//Question 12 - Write addFirst(T element).

//Answer 12:
public void addFirst(T element) {
    DNode<T> newNode = new DNode<>(element);

    if (size == 0) {
        head = tail = newNode;
    } else {
        newNode.next = head;
        head.prev = newNode;
        head = newNode;
    }
    size++;
}


//Question 13 - Write removeFirst() that throws exception if empty.

//Answer 13:
public T removeFirst() {
    if (size == 0) throw new IllegalStateException("List empty");

    T item = head.data;
    head = head.next;

    if (head != null) head.prev = null;
    else tail = null;

    size--;
    return item;
}


//Question 14 - Write a traversal method that prints elements from head to tail.

//Answer 14:
public void traverse() {
    DNode<T> current = head;
    while (current != null) {
        System.out.println(current.data);
        current = current.next;
    }
}

//Question 15 - ADT vs Data Structure - Explain the difference and give one example of each.

//Answer 15:
/*ADT = logical model (e.g., Stack).
Data Structure = physical implementation (array, linked list).*/

//Question 16 - Bounded vs Unbounded - Give one Java example of each and explain.

//Answer 16:
/*Bounded: Array (fixed capacity)
Unbounded: ArrayList (grows dynamically)*/

//Question 17 - Exception Scenario - Why must removing from an empty collection throw an exception?

//Answer 17:
/*Removing from empty collection is an illegal state — operation cannot be performed.*/

//Question 18 - Write a method that reverses a stack using only stack operations.

//Answer 18:
public static <T> void reverse(StackADT<T> stack) {
    StackADT<T> temp = new LinkedStack<>();

    while (!stack.isEmpty())
        temp.push(stack.pop());

    while (!temp.isEmpty())
        stack.push(temp.pop());
}

//Question 19 - Implement a queue using two stacks

//Answer 19:
public class TwoStackQueue<T> implements QueueADT<T> {

    private StackADT<T> inStack = new LinkedStack<>();
    private StackADT<T> outStack = new LinkedStack<>();

    public void enqueue(T element) {
        inStack.push(element);
    }

    public T dequeue() {
        if (isEmpty()) throw new IllegalStateException("Queue empty");

        if (outStack.isEmpty())
            while (!inStack.isEmpty())
                outStack.push(inStack.pop());

        return outStack.pop();
    }

    public T first() {
        if (isEmpty()) throw new IllegalStateException("Queue empty");

        if (outStack.isEmpty())
            while (!inStack.isEmpty())
                outStack.push(inStack.pop());

        return outStack.peek();
    }

    public boolean isEmpty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    public int size() {
        return inStack.size() + outStack.size();
    }
}


