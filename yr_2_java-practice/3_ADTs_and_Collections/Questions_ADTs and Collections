//Question 1 - Array Stack (Bounded)- Write a generic class ArrayStack<T> that implements StackADT<T> using an array.

//Answer 1:
public class ArrayStack<T> implements StackADT<T>, Bounded {
  private T[] stack;
  private int top;

  public ArrayStack(int capacity) {
    stack = (T[]) new Object[capacity];
    top = 0;
  }

  public void push (T element) {
    if (isFull()) throw new IllegalStateException("Stack is full!");
    stack[top++] = element;
  }

public T pop() {
    if (isEmpty()) throw new IllegalStateException("Stack is empty!");
    T item = stack[--top];
    stack[top] = null;
    return item;
}

public T peek() {
  if (isEmpty()) throw new IllegalStateException("Stack is empty");
  return stack[top - 1];
}

public boolean isEmpty(){ return top == 0; }
public int size() { return top; }
public boolean isFull() { return top == stack.length; }
public int capacity() { return stack.length; }
}


//Question 2 - Linked Stack (Unbounded) - Implement LinkedStack<T> using a singly linked list.

//Answer 2:

public class LinkedStack<T> implements StackADT<T>{
  private Node<T> top;
  private int size;

  private static class Node<T>{
    T data;
    Node<T> next;
    Node (T data, Node<T> next) {
      this.data = data;
      this.next = next;
    }
  }
    public void push(T element){
    top = new Node<>(element, top);
    size++;
  }
  public T pop() {
    if (isEmpty()) throw new IllegalStateException("Stack empty");
    T item = top.data;
    top = top.next;
    size--;
    return item;
  }
  public T peek(){
    if (isEmpty()) throw new IllegalStateException("Stack empty");
    return top.data;
  }
  public boolean isEmpty(){ return size == 0; }
  public int size() { return size; }
}

//Question 3 - Trace Question - Trace stack contents after:

/*push(10); push(20); push(30);
pop();
push(40);
peek();*/

//Answer 3:
/**push(10) → [10]
push(20) → [20,10]
push(30) → [30,20,10]
pop()    → [20,10]
push(40) → [40,20,10]
peek()   → 40

Final stack (top → bottom): 40, 20, 10*/

//Question 4 - Modify pop() so it throws IllegalStateException when stack is empty.

//Answer 4:
public T pop() {
  if (isEmpty()) throw new IllegalStateException("Stack empty");
  T item = top.data;
  top = top.next;
  size--;
  return item;
}

//Question 5 - Interface - Write the interface QueueADT<T>.

//Answer 5:
public interface QueueADT<T>{
  void enqueue(T element);
  T dequeue();
  T first();
  boolean isEmpty();
  int size();
}

//Question 6 - Circular Array Queue - Implement a bounded queue using a circular array.

//Answer 6:


//Question 7 - Linked Queue -Write a class LinkedQueue<T> using front and rear pointers.

//Question 8 - Explain why a supermarket checkout is modeled by a queue rather than a stack.

//Question 9 - Node Class - Write a generic Node<T> class for a singly linked list.

//Question 10 - Doubly Linked Node - Write a node class with prev and next.

//Question 11 - Method Writing
//In DoublyLinkedList<T> write:

/*public void addLast(T element)*/

//Question 12 - Write addFirst(T element).

//Question 13 - Write removeFirst() that throws exception if empty.

//Question 14 - Write a traversal method that prints elements from head to tail.

//Question 15 - ADT vs Data Structure - Explain the difference and give one example of each.

//Question 16 - Bounded vs Unbounded - Give one Java example of each and explain.

//Question 17 - Exception Scenario - Why must removing from an empty collection throw an exception?

//Question 18 - Write a method that reverses a stack using only stack operations.

//Question 19 - Implement a queue using two stacks



